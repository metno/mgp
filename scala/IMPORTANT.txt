On the other hand, it can be really hard to write useful applications that don’t affect files,
databases, or sockets, so it is rare to write one that only contains pure functions. Instead of
trying to find a way to exlusively use pure functions in their applications, Scala developers will
generally compromise and seek ways to reduce the number of unpure functions. Keeping unpure
functions clearly named and organized in such a way that they can be easily identified versus pure
functions is a common goal of modularizing and organizing Scala applications.

==================================================================================

Functions with Side Effects Should Use Parentheses

A Scala convention for input-less functions is that they should be defined with empty parentheses if
they have side effects (i.e., if the function modifies data outside its scope). For example, an
input-less function that writes a message to the console should be defined with empty parentheses.

==================================================================================

As a matter of style it’s better to organize function parameters so that those with default values
follow required parameters. This emphasizes the importance of the required parameters as well as
making it possible to call the function without specifying the default parameters and not require
the use of parameter names.

==================================================================================

Scala’s support for infix operator notation for invoking object methods has multiple benefits for
the language. Operators, instead of being a part of the syntax and imple‐ mented in hidden ways, are
just methods implemented in their objects that can be viewed or called directly. The syntax is thus
reduced and simplified. Developers are free to implement their own operators because every
single-parameter method can be used as an operator, and are motivated to simplify methods to only
take a single parameter to make them eligible for operator notation. Finally, the code readability
may be im‐ proved, removing otherwise necessary punctuation to focus on the simple object, meth‐ od,
and parameter components.

About the only drawback to using operator notation is when it reduces code readability instead of
improving it. For example, a chain of 10 method calls separated only by spaces may be a bit harder
to read than with regular dot notation, because the operators and operands may be hard to
discern. Or an overeager developer may define his own type with an addition operator that,
unknowingly to callers, performs a completely different type of operation.

Make sure to use care to invoke operator notation only when it can be clearly read, and you may find
yourself using it regularly

==================================================================================

Scaladoc (or Javadoc, if you prefer) headers are a standard format for function com‐ ments. Adding
them to your functions is a good practice to follow even if you don’t plan on generating API
documentation. Developers reading your function will likely start with the Scaladoc header before
reading the function’s code, so make sure to keep it accurate and concise.

==================================================================================

Why Not Just Call Them Anonymous Functions?

Although The Scala Language Specification (Odersky, 2011) uses the term anonymous function, this
term focuses more attention on the lack of a name than on the interesting arrow-based syntax for
defin‐ ing its logic. Thus I prefer the clarifying term function literal, which indicates that the
entire logic of a function body is being specified inline! You can think of a function literal as
being to a function val‐ ue what a string literal (e.g., “Hello, World”) is to a string value: a
literal expression of the assigned data.

==================================================================================

If you think about it, a function literal is essentially a parameterized expression. We know about
expressions that return a value, but now have a way to parameterize their input.

==================================================================================

What Is the Difference Between Partial and Partially Applied Functions?

The two terms look and sound almost the same, causing many de‐ velopers to mix them up. A partial
function, as opposed to a total function, only accepts a partial amount of all possible input
values. A partially applied function is a regular function that has been partial‐ ly invoked, and
remains to be fully invoked (if ever) in the future.

==================================================================================

An important point to make about these arithmetic methods is that ::, drop, and take act on the
front of the list and thus do not have performance penalties. Recall that List is a linked list, so
adding items to or removing items from its front does not require a full traversal. A list traversal
is a trivial operation for short lists, but when you start getting into lists of thousands or
millions of items, an operation that requires a list traversal can be a big deal.

That said, these operations have corollary operations that act on the end of the list and thus do
require a full list traversal. Additionally, because adding items to the end of a list would mutate
it, they require copying the entire list and returning the copy. Again, not an important memory
consideration unless you are working with large lists, but in general it is best to operate on the
front of a list, not its end.

==================================================================================
